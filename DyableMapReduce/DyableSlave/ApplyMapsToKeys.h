#include "./OrderMappedSets.h"

// This class is a utility class that maps an arbitary set of 
// keys in a file to a predefined mapping of nodes externally.
// This process can be performed in parallel accross multiple 
// clients in O(N / C) time where N are the total number of keys
// and C is the total number of clients. This class is generally
// like an external hash map that is designed to work on sets
// of objects that are too large to fit into internal memory.

// This class accomplishes a mapping between keys and their values
// through the use of external hashing. The term bucket set is 
// introduced to refer to a set of keys that all have a compression
// function value that fall in the same set. Each bucket set is 
// small enough such that all the mappings in a bucket set can fit
// into memory. The mapping is then applied to the local set of keys
// that fall in a bucket set. This mapping is then applied for all
// the buckets until the global key set has been mapped.

// Internally keys and maps are hashed first into client sets and a 
// client is responsible for mapping a subset of the keys. After the
// mapping has been applied, the mapping for each of the keys need 
// to be written out to file in the same order that the keys originally
// appeared for a given client. This is so the client can take the 
// returned mappings with the gaurantee that they appeared in the same
// order. To accomplish this a stat file is kept to record to which 
// bucket set for a given client a key was hashed to in the order that
// each key appeared. It is then possible to sequentially read this 
// stat file and retreive the mappings in the same order.
class CApplyMapsToKeys : public CSetNum {

	// This stores the internal mapping between a key
	// and its respective value for a given bucket division
	CHashDictionary<int> m_key_map;
	// This stores the value for a respective key
	CArrayList<char> m_value_map;
	// This stores the offset of each value in the buffer
	CArrayList<int> m_value_offset;

	// This stores the maximum number of bytes that make up a key
	int m_max_key_bytes;
	// This stores the maximum number of bytes that make up a map value
	int m_max_map_bytes;
	// This stores the directory for the node map
	char m_directory[500];

	// This loads in the mapping between keys and values for
	// a given client, that was generated by each client. This 
	// is stored in an ObjectHashMap. This is so that an arbitary
	// key set that has been hashed to a given bucket can be 
	// mapped appropriately.
	// @param map_file - this stores the mapping for keys
	void LoadKeyValueMappings(CHDFSFile &map_file) {

		uLong key_bytes;
		uLong map_bytes;

		CMemoryChunk<char> key_buff(m_max_key_bytes);
		CMemoryChunk<char> map_buff(m_max_map_bytes);

		while(map_file.GetEscapedItem(key_bytes) >= 0) {
			map_file.GetEscapedItem(map_bytes);

			if(key_bytes > m_max_key_bytes) {
				cout<<"key not1 "<<key_bytes;getchar();
			}

			if(map_bytes > m_max_map_bytes) {
				cout<<"map not1 "<<map_bytes;getchar();
			}

			map_file.ReadCompObject(key_buff.Buffer(), key_bytes);
			map_file.ReadCompObject(map_buff.Buffer(), map_bytes);

			m_key_map.AddWord(key_buff.Buffer(), key_bytes);

			if(m_key_map.AskFoundWord() == false) {
				m_value_map.CopyBufferToArrayList(map_buff.Buffer(), 
					map_bytes, m_value_map.Size());
				m_value_offset.PushBack(m_value_map.Size());
			}
		}
	}


	// This processes an arbitary key set to apply the mapping to 
	// the keys. It's assumed that all keys have a mapping otherwise
	// an exception is thrown.
	// @param key_file - this stores the set of keys yet to be mapped
	// @param set_id - this is the current set being processed
	void ApplyMappingToKeys(CHDFSFile &key_file, int set_id) {

		CHDFSFile new_key_file;
		new_key_file.OpenWriteFile(CUtility::ExtendString
			(m_directory, ".mapped_set", CSetNum::GetClientID(), ".client", set_id));

		uLong bytes;
		int key_bytes;
		CMemoryChunk<char> key_buff(m_max_key_bytes);
		while(key_file.GetEscapedItem(bytes) >= 0) {

			key_bytes = bytes;
			key_file.ReadCompObject(key_buff.Buffer(), key_bytes);
			int id = m_key_map.FindWord(key_buff.Buffer(), key_bytes);

			if(m_key_map.AskFoundWord() == false) {
				new_key_file.AddEscapedItem(key_bytes);
				new_key_file.AddEscapedItem((int)0);
				new_key_file.WriteCompObject(key_buff.Buffer(), key_bytes);
				continue;
			}

			int map_bytes = m_value_offset[id+1] - m_value_offset[id];
			char *map_value = m_value_map.Buffer() + m_value_offset[id];

			if(map_bytes > m_max_map_bytes) {
				cout<<"max map 1";getchar();
			}

			if(key_bytes > m_max_key_bytes) {
				cout<<"max key 1";getchar();
			}

			new_key_file.AddEscapedItem(key_bytes);
			new_key_file.AddEscapedItem(map_bytes);
			new_key_file.WriteCompObject(key_buff.Buffer(), key_bytes);
			new_key_file.WriteCompObject(map_value, map_bytes);
		}
	}

public:

	CApplyMapsToKeys() {
	}

	// This takes the hashed key set generated for a specific client
	// and maps each key to its respective value. These key mappings
	// must then be written back to a client file that requested them.
	// This is so they can be read back in the same order that they were
	// written allowing for the correct mapping to be applied.
	// @param dir - the directory where the node map is stored
	// @param bound - this is the range of client sets for the current division
	//              - for which this client is responsible
	// @param max_key_bytes - this stores the maximum number of bytes that 
	//                      - make up a key
	// @param max_map_bytes - this stores the maximum number of bytes that
	//                      - make up a map value
	void PerformMapping(const char dir[], SBoundary &bound, int max_key_bytes, int max_map_bytes) {

		strcpy(m_directory, dir);
		m_max_key_bytes = max_key_bytes;
		m_max_map_bytes = max_map_bytes;

		CHDFSFile curr_key_file;
		CHDFSFile curr_map_file;

		m_key_map.Initialize();
		m_value_map.Initialize((MAX_MAPRED_BYTES / m_max_map_bytes) + 1000);
		m_value_offset.Initialize(m_value_map.OverflowSize());
		m_value_offset.PushBack(0);

		for(int j=0; j<CSetNum::GetMapClientNum(); j++) {
			curr_map_file.OpenReadFile(CUtility::ExtendString
				(m_directory, ".map_set", CSetNum::GetClientID(), ".client", j));
					
			LoadKeyValueMappings(curr_map_file);
		}
			
		for(int j=bound.start; j<bound.end; j++) {
			// next load the arbitary keys that need to be mapped
			curr_key_file.OpenReadFile(CUtility::ExtendString
				(m_directory, ".key_set", CSetNum::GetClientID(), ".client", j));

			ApplyMappingToKeys(curr_key_file, j);
		}
	}

};