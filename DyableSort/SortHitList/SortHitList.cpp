#include "./TestSortHitList.h"

// This stores the directory where the mapping between 
// base nodes and their cluster mapping is stored
const char *FORWARD_CLUS_MAP_DIR = "GlobalData/ClusterHiearchy/forward_clus_map";

// This is the main class that takes the list of hit items for the
// given sort division generated by each client and merges them together.
// Hits are merged by doc id to obtain a sequential run of doc id's. This 
// is so pulse scores can be attatched to each hit item and also the doc
// id's can be remapped to that generated in the hiearchy. 
class CSortHitList : public CNodeStat {

	// This stores the mapping between doc id and cluster hiearchy node
	CHDFSFile m_clus_map_file;
	// This stores the merged hits for this sort division
	CFileComp m_fin_hits_file;

	// This store the current doc id cluster mapping
	SClusterMap m_curr_doc_map;
	// This stores the current doc id
	_int64 m_curr_doc_id;

	// This sorts the anchor hits by doc id so that they 
	// can be merged with the other hits.
	void SortAnchorHits() {

		CFileComp anchor_file;
		for(int i=0; i<GetClientNum(); i++) {
			anchor_file.OpenReadFile(CUtility::ExtendString
				("GlobalData/HitList/anchor_fin_hit",
				GetClientID(), ".client", i));

			CExternalRadixSort sort(11, anchor_file.CompBuffer(), 5);
		}
	}

	// This merges the hits from each of the different clients based upon
	// their doc id. It then proceeds to remap each doc id with the new
	// cluster hiearchy cluster mapping. It also assigns the pulse score
	// for each hit item. Normal hit items and image hit items must be 
	// placed into different files and sorted seperately.
	// @param hit_list_file - this is the current hit list being compiled
	void MergeHitItems(CHDFSFile &hit_list_file) {

		int count = 0;
		SHitItem hit_item;
		while(hit_item.ReadHitDocOrder(hit_list_file)) {

			while(hit_item.doc_id > m_curr_doc_id) {
				m_curr_doc_map.ReadClusterMap(m_clus_map_file);
				m_curr_doc_id++;
			}

			if(hit_item.doc_id != m_curr_doc_map.base_node) {
				cout<<"Doc ID Mismatch "<<hit_item.doc_id.Value()
					<<" "<<m_curr_doc_map.base_node.Value();getchar();
			}

			if(hit_item.IsImageHit() == false) {
				hit_item.doc_id = m_curr_doc_map.cluster;
				hit_item.WriteHitWordOrder(m_fin_hits_file);
			}

			if(++count >= 10000) {
				float percent = hit_list_file.PercentageFileRead();
				percent /= CNodeStat::GetClientNum();
				cout<<(percent * 100)<<" % Hit Merged"<<endl;
				count = 0;
			}
		}
	}

public:

	CSortHitList() {
		CHDFSFile::Initialize();
	}

	// This is called to initialize the number of clients and 
	// the sort division before sorting commences
	// @param sort_div - this is the sort division being sorted
	// @param client_num - this is the number of client sets
	void SortHitList(int sort_div, int client_num) {
		CNodeStat::SetClientID(sort_div);
		CNodeStat::SetClientNum(client_num);

		m_clus_map_file.SetFileName(CUtility::ExtendString
			(FORWARD_CLUS_MAP_DIR, ".fin"));

		m_fin_hits_file.OpenWriteFile(CUtility::ExtendString
			("GlobalData/SortedHits/sorted_base_hits", GetClientID()));

		m_curr_doc_id = 0;
		m_clus_map_file.OpenReadFile();
		m_curr_doc_map.ReadClusterMap(m_clus_map_file);
		CHDFSFile hit_list_file;
		for(int i=0; i<CNodeStat::GetClientNum(); i++) {
			cout<<"Base Div "<<i<<" Out Of "<<CNodeStat::GetClientNum()<<endl;

			try {
				hit_list_file.OpenReadFile(CUtility::ExtendString
					("GlobalData/HitList/base_fin_hit", GetClientID(), ".client", i));
				MergeHitItems(hit_list_file);
			} catch(...) {
			}
		}

		m_curr_doc_id = 0;
		m_clus_map_file.OpenReadFile();
		m_curr_doc_map.ReadClusterMap(m_clus_map_file);
		for(int i=0; i<CNodeStat::GetClientNum(); i++) {
			cout<<"Assoc Div "<<i<<" Out Of "<<CNodeStat::GetClientNum()<<endl;
			try {
				hit_list_file.OpenReadFile(CUtility::ExtendString
					("GlobalData/HitList/assoc_fin_hit", GetClientID(), ".client", i));
				MergeHitItems(hit_list_file);
			} catch(...) {	
			}
		}

		if(m_fin_hits_file.CompBuffer().BytesStored() > 0) {
			CExternalRadixSort sort1(11, m_fin_hits_file.CompBuffer());
		}

		CTestSortHitList test;
		test.TestSortHitList();
	}
};

int main(int argc, char *argv [])
{

	if(argc < 3)return 0; 
	int sort_div = atoi(argv[1]);
	int client_num = atoi(argv[2]);
	
	cout<<"Client "<<sort_div<<endl;
	CBeacon::InitializeBeacon(sort_div, 2222);
	CMemoryElement<CSortHitList> hit_list_div;
	hit_list_div->SortHitList(sort_div, client_num);
	hit_list_div.DeleteMemoryElement();
	CBeacon::SendTerminationSignal();

}
